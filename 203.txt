Question. 203)--> Remove Linked List Elements

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.

solution.)-->
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(head == NULL) return NULL;

        while(head != NULL && head->val == val){
            ListNode* toDel = head;
            head = head->next;
            delete toDel;
        }

        if(head == NULL) return NULL;
        ListNode* temp = head;
        while(temp->next != NULL){
            if(temp->next->val == val){
                ListNode* toDel = temp->next;
                temp->next = temp->next->next;
                delete toDel;
            }
            else{
                temp = temp->next;
            }
        }

        return head;

    }
};

In this question edges cases are more important if you don't want to take extra space complexity.
For head pointer you have to check again that value is null or not. 

Time Complexity :- O(n)
Space Complexity :- O(1)

Method 2 - By Recursion
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(head == NULL){
            return NULL;
        }
        // We call function
        head->next = removeElements(head->next, val);
        if(head->val == val){
            // return head->next;
            ListNode* temp = head->next;
            delete head;
            return temp;
        }
        else{
            return head;
        }
    }
};
