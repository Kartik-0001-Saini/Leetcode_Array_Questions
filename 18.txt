Question 18.) 4 Sum
Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

0 <= a, b, c, d < n
a, b, c, and d are distinct.
nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.

solution.)

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        int n = nums.size();
        if (n < 4) return res;

        sort(nums.begin(), nums.end());
        long long T = target; // work in 64-bit for safety

        for (int i = 0; i < n - 3; ++i) {
            // Skip duplicate i
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            // Early pruning for i
            long long min1 = (long long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3];
            if (min1 > T) break; // since nums is sorted, sums will only increase
            long long max1 = (long long)nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3];
            if (max1 < T) continue; // even the largest sum with this i is too small

            for (int j = i + 1; j < n - 2; ++j) {
                // Skip duplicate j for the same i
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;

                // Early pruning for j
                long long min2 = (long long)nums[i] + nums[j] + nums[j + 1] + nums[j + 2];
                if (min2 > T) break; // further j will only increase min2
                long long max2 = (long long)nums[i] + nums[j] + nums[n - 1] + nums[n - 2];
                if (max2 < T) continue; // try next j

                int m = j + 1, r = n - 1;
                while (m < r) {
                    long long sum = (long long)nums[i] + nums[j] + nums[m] + nums[r];

                    if (sum == T) {
                        res.push_back({nums[i], nums[j], nums[m], nums[r]});
                        
                        int lastM = nums[m], lastR = nums[r];
                        while (m < r && nums[m] == lastM) ++m;
                        while (m < r && nums[r] == lastR) --r;
                    } else if (sum < T) {
                        ++m;
                    } else {
                        --r;
                    }
                }
            }
        }
        return res;
    }
};

Time Complexity :- O(n^3)
